# 모르는 개념/용어 정리




### Sandbox

> **시스템 전체에 영향을 주지 않고 코드를 제한된 환경 안에서 실행 시키는 것**
> 

→ Q) 샌드박스 영역은 시스템 전체에 영향을 주지 않고 코드를 제한된 환경 안에서 실행

→ 커널이 해당 코드의 권한을 제한 ( 일정 부분까지만 접근 가능해짐)

### execute

> **CPU가 메모리에서 가져온 instruction(명령어)을 실제로 처리하는 단계**
> 

Fetch(명령어를 메모리에서 읽어옴) → Decode(무슨 명령인지 해석) → Execute(명령을 실행)

이후 interrupt or 다음 instrtuction으로 이동

### Tracing

> **운영체제나 프로그램의 동작 흐름을 관찰하는 행위**
> 

eBPF에서는 특정 시스템 콜, 함수 진입 시점, 네트워크 이벤트 , 파일 접근 등을 중단 없이  

실시간으로, 가볍게 감시

### hook

> **커널의 특정 지점에 나만의 코드를 끼어 넣는 것**
> 

→ 어떤 이벤트가 발생할 때 갈고리처럼 내 코드가 먼저/같이 실행되도록 걸어두는 것

### RISC

> **Reduced Instruction Set Computer: 간단한 명령어 집합을 가진 CPU 설계 방식**
> 
- 하나의 명령어가 단순 → 실행 속도가 빠름
- 명령어가 거의 다 1클럭(싸이클)에 끝남
- HW의 복잡도를 줄이고 컴파일러와 SW가 똑똑해야함

### Register

> **CPU 내부에 있는 초고속 기억장치**
> 
- eBPF에는 총 11개 레지스터
    - r0: 결과 저장용
    - r1 ~ r5: helper 함수 인자 전달용
    - r6 ~ r9: 보존용 (callee-saved)
    - r10: 스택 프레임 포인터

### Stack

> **함수 호출 시 지역 변수나 인자 등을 저장하는 LIFO 구조 (후입선출)**
> 
- 값이 많거나 레지스터가 부족하면 → 스택에 spill(Register → Stack) 하여 저장하고,
 다시 fill(Stack → Register) 해서 가져옴
- 레지스터는 eBPF에서는 11개 한정이기에 부족한 공간을 Stack을 통해 활용
- stack은 공간 확보때 위에서 아래로 자리를 잡는다. 즉 제일 위에가 스택의 시작이고 스택의 크기만큼 내려간다

### Helper Function

> **eBPF 프로그램이 커널과 상호작용할 수 있도록 커널에서 제공하는 안전한 기능 호출 API**
> 

→ 맵 접근, 유저 공간 통신, 패킷 수정 등에 사용된다

→ 커널 내부에 `BPF_CALL_n()` 매크로로 등록된다.

### Maps

> **커널 공간에 존재하는 고성능 Key-Value 저장소**
> 

→ 커널은 RAM을 User Space / Kernel Space로 나누어 사용하고 eBPF map은 커널 공간의 일부 메모리를 사용한다

- eBPF는 기본적으로 statelsess (상태를 기억하지 않음)

→ 하지만 로그를 기록하거나, 상태를 비교하거나, 누적하려면 상태 저장해야함

→ 이때 사용되는 것이 Map 이다.

Map의 기능

- eBPF 프로그램 내부에서 값을 조회/수정/삭제 가능
- 여러 BPF 프로그램 간에 공유 가능 (서로 타입 달라도 OK)
- User Space 프로그램에서도 접근 가능 → file descriptor로 접근하여 데이터를 주고 받을 수 있음

### attach

> **eBPF 프로그램을 커널의 특정 이벤트 지점(hook point)에 연결하는 것을 의미**
> 

### rsp

> **Stack Pointer. 현재 스택의 “꼭대기” 주소를 가리키는 레지스터**
> 

### Local Variable

> **지역변수. 특정 함수 블록 내에서만 유효한 변수. 스택에 저장된다.**
> 

→ 함수가 호출될 때 생성되고, 끝나면 사라짐

### Global Variable

> **프로그램 전체에서 접근 가능. 데이터 세그먼트**
> 

→ 프로그램이 시작할 때 생성되고, 종료될 때까지 유지된다.

### Bytecode

> **고급 언어(사람이 읽을 수 있는)를 기계가 이해할 수 있는 중간 언어로 변환된 코드**
> 

→ eBPF의 경우에는 커널에 직접 프로그램을 삽입하므로, 바이트코드를 통해 검증이 필요함

### /proc

> **실제 디렉토리가 아닌 가상 파일 시스템. 커널이 메모리에 실시간으로 만들어주는 정보 파일들.**
> 

### kallsyms

> /proc/kallsyms 는 커널 내부 심볼 테이블을  노출하는 파일. 커널 함수나 전역 변수의 메모리 주소가 리스트로 구성되어 있다.
> 

### Static Tracepoint

> **미리 준비된 고정된 hook point**
> 

[Linux Kernel TracePoints](https://docs.kernel.org/trace/tracepoints.html)

### Makefile

> **빌드할 파일과 빌드 방법을 정의해서, make 명령으로 자동 컴파일되도록 만들어주는 빌드 스크립트**
> 

| **요소** | **의미** | **예시** |
| --- | --- | --- |
| **target** | 만들려는 산출물 | main, prog.o, clean |
| **dependencies** | target을 만들기 위해 필요한 파일들 | main.c, main.bpf.c, loader.c |
| **명령어** | 어떤 명령으로 컴파일할지 | gcc, clang, rm, echo 등 |

명령어 줄에는 **반드시 tab 문자**가 들어가야 한다(space X)

### execve()

> **현재 프로세스의 메모리 공간을 새 프로그램으로 완전히 갈아 끼는 시스템 콜**
> 

### Header Guard

> 여러 .c 파일에서 중복 include 되는 걸 막기 위한 방법
> 

```c
#ifndef DISPATCH_H_
#define DISPATCH_H_

//your code goes here

#endif //DISPATCH_H_
```

위와 같은 패턴으로 사용된다.

( if not define → define)

### PreProcessor

> **컴퓨터의 처리에 있어서 중심적인 처리를 수행하는 부분을 위해 사전 준비적인 계산을 행하는 프로그램**
> 

→ 전처리기

### max_entries

> **해당 map에서 얼마나 많은 키-값 쌍을 저장할 수 있냐를 의미**
> 

### ctx

> **커널이 eBPF 프로그램에 전달하는 시스템 콜 진입 당시의 레지스터 상태를 담은 구조체 포인터**
> 

### perf buffer

> **커널에서 유저 공간으로 데이터를 보내는 통로**
> 

### >>32 / & 0xFFFFFFFF

> >>32는 상위 32비트 값만 쓰겠다 (앞에 32비트를 이동한거니까)
> 

> & 0xFFFFFFFF 하위 32비트 값만 쓰겠다라는 마스킹 연산
> 

### __uint()

> **libbpf가 제공하는 BTF 삽입용 매크로 /** 
**libbpf에서 map을 정의할 때 사용하는 특수한 BPF helper macro**
> 
- 내부적으로 map의 속성을 정의해주는 설정자

### volatile

> **C언어의 컴파일러 지시자, 휘발성 자료를 의미**
> 
- “최적화 하지 말고 메모리에서 읽어라”
    - 컴파일러는 성능을 위해 똑똑하게 코드를 바꿔버리기도 한다.
    - 근데 exiting은 시그널 핸들러에서 바뀌고 그걸 컴파일러가 모른다
    - 그래서 언제든 외부에서 값이 바뀔 수 있으니 항상 메모리에서 직접 읽어와라

### sig_atomic_t

> **시그널 안전하게 다루는 정수 타입**
> 
- 시그널 핸들러는 언제든 실행될 수 있어서 데이터를 바꾸는 도중 끼어들 수 있다
- 그런 걸 막기 위해 단일 동작 보장

### buffer

> **메모리의 임시 저장소**
> 

### perf_buffer

> **커널과 사용자 공간 사이의 실시간 통신 통로**
> 
- ring buffer 기반이라서 꽉 차면 데이터 유실 가능
    
    → lost 핸들러 호출
    

### SIGINT

> 운영체제 시그널의 일종, 그 중에서도 Interrupt 시그널
> 

### Sync / Async

> sync (동기): 순차적으로 명령하고 기다리는 방식→다음 코드가 실행되기 위해선 이전 코드가 끝나야 함
> 

> async(비동기): 명령하지 않아도 외부에서 갑자기 끼어드는 것. 코드 흐름과 무관하게 발생
> 

### pointer

> “선언할때는 참조, 실행할때는 역참조.
포인터는 선언과 사용이 다르다.
선언은 ‘주소를 담는 놈이다’
사용은 ‘주소를 따라가서 값을 꺼낸다’”
>